# 最短路径问题

## 1.Dijkstra算法

初始化，将，0到0的距离设置为0，接下来进行n轮循环：

* 选出最小的dist[i]，然后将visited[i]=true;
* 用最小的dist[i]去更新与i相连的节点，如果dist[i]+grid[i] [j]<dist[j]，dist[j]=dist[i]+grid[i] [j],并记录到对应存放更新后dist的队列或者数组中。
* 重复上述步骤

n轮之后可以得到0-(1~n)的min_dist.

例如：

![image-20241023213330806](最短路径问题.assets/image-20241023213330806.png)

![image-20241023213348609](最短路径问题.assets/image-20241023213348609.png)



### 不适合负权边存在的情况!!



## 2.Bellman-Ford 算法

### 1.算法流程：

* 初始化：将dist[1]设为0
* 遍历每一条边，当出现dist[end]>dist[start]+weight[start->end]时，dist[end]=dist[begin]+weight[start->end]
* 重复n-1轮可得到结果（不存在负权自环，或者负权环的情况），或者当所有节点的dist都没有更新时，退出循环，当循环次数大于n时，表示存在负权自环或者负权环，无法求出最短距离，退出。

### 2.模板

```C++
//Bellman-Ford算法
edge[m];//m条边
dist[n];//n个点距离初始点最短距离

//初始化
memset(dist, 0x3f, sizeof dist);
dist[1]=0;//设求的是距离1最近的点。

for(int i=0;i<n-1;i++){//n-1轮循环
    for(int j=0;j<m;j++){//遍历每一条边
        int s=edge[i].start,e=edge[i].end,w=edge[i].weight;
        dist[e]=min(dist[e],dist[s]+w);
    }
}

//如果有限制，通过edge数不超过K条，可以改为for(int i=0;i<k-1;i++)

```

### 3.总结

* 复杂度为O(n*m)
* 可以用来处理带负权边的图，也可以用来判断存在负权自环或者负权环(但是不建议)。



